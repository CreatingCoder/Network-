<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>BCDR Quiz - Network+</title>
  <style>
    body {
      background-color: #121212;
      color: #f0f0f0;
      font-family: Arial, sans-serif;
      padding: 20px;
      max-width: 800px;
      margin: auto;
    }

    h1 {
      text-align: center;
      color: #00e6e6;
      margin-bottom: 20px;
    }

    .question {
      background-color: #1e1e1e;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 20px;
    }

    .question h3 {
      margin-top: 0;
    }

    .options label {
      display: block;
      padding: 8px;
      border-radius: 4px;
      background: #2c2c2c;
      margin: 5px 0;
      cursor: pointer;
    }

    .feedback {
      margin-top: 10px;
      font-weight: bold;
    }

    .correct {
      color: #00ff99;
    }

    .incorrect {
      color: #ff4c4c;
    }

    @media (max-width: 600px) {
      .question h3 {
        font-size: 1.1rem;
      }
    }
  </style>
</head>
<body>
  <h1>BCDR Terms Quiz - Network+ N10-009</h1>
  <form id="quizForm"></form>

  <script>
    const questions = [
      {
        question: "What does RTO stand for?",
        correct: "Recovery Time Objective",
        options: [
          "Redundant Time Objective",
          "Recovery Time Objective",
          "Return to Operation",
          "Restore Target Objective"
        ]
      },
      {
        question: "What does RPO determine?",
        correct: "Maximum acceptable data loss",
        options: [
          "Maximum acceptable data loss",
          "Time needed to recover hardware",
          "Network throughput after disaster",
          "Cost of downtime"
        ]
      },
      {
        question: "MTTR refers to:",
        correct: "Mean Time to Repair",
        options: [
          "Maximum Time to Repair",
          "Most Time to Restore",
          "Mean Time to Repair",
          "Minimal Time to Replace"
        ]
      },
      {
        question: "What does MTBF measure?",
        correct: "Average time between failures",
        options: [
          "Time between system reboots",
          "Time to fail after startup",
          "Time needed for full backup",
          "Average time between failures"
        ]
      },
      {
        question: "What is the purpose of fault tolerance?",
        correct: "Keep services running during failure",
        options: [
          "Increase bandwidth",
          "Detect viruses",
          "Keep services running during failure",
          "Schedule firmware updates"
        ]
      },
      {
        question: "A hot standby server that takes over if the primary fails is an example of:",
        correct: "Failover",
        options: [
          "Failover",
          "Backup rotation",
          "Segmentation",
          "Load balancing"
        ]
      },
      {
        question: "What is the primary goal of redundancy?",
        correct: "Eliminate single points of failure",
        options: [
          "Speed up backups",
          "Eliminate single points of failure",
          "Encrypt data at rest",
          "Reduce power usage"
        ]
      },
      {
        question: "Which metric focuses on the expected uptime and downtime of a system?",
        correct: "Availability",
        options: [
          "MTTR",
          "RPO",
          "Availability",
          "RTO"
        ]
      }
    ];

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    const form = document.getElementById("quizForm");

    questions.forEach((q, index) => {
      const qDiv = document.createElement("div");
      qDiv.className = "question";
      qDiv.dataset.correct = q.correct;

      const qTitle = document.createElement("h3");
      qTitle.innerText = `${index + 1}. ${q.question}`;
      qDiv.appendChild(qTitle);

      const feedback = document.createElement("div");
      feedback.className = "feedback";
      feedback.id = `feedback-${index}`;

      const options = [...q.options];
      shuffle(options);

      options.forEach(opt => {
        const label = document.createElement("label");
        label.innerHTML = `
          <input type="radio" name="q${index}" value="${opt}">
          ${opt}
        `;
        label.querySelector("input").addEventListener("change", function () {
          if (this.value === q.correct) {
            feedback.textContent = "✅ Correct!";
            feedback.className = "feedback correct";
          } else {
            feedback.textContent = "❌ Incorrect.";
            feedback.className = "feedback incorrect";
          }
        });
        qDiv.appendChild(label);
      });

      qDiv.appendChild(feedback);
      form.appendChild(qDiv);
    });
  </script>
</body>
</html>
